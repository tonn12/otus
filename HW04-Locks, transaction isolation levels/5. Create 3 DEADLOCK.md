1. Очищаем таблицу от старых данных
TRUNCATE TABLE test_table;

2. Проверяем что таблица пустая (должно выдать (0 rows) )
SELECT id FROM test_table ORDER BY id;

3. Создадим в нашей тестовой БД три стори с данными
INSERT INTO test_table (id, content)
VALUES (1, 'A'), (2, 'B'), (3, 'C')
ON CONFLICT (id) DO NOTHING;

4. Проверяем что даннеы добавились
SELECT * FROM test_table;

5. Выполняем запрос на изменения в первой сессии
BEGIN;
UPDATE test_table SET content = 'locked A' WHERE id = 1;

6. Выполняем запрос на изменение во второй сессии
BEGIN;
UPDATE test_table SET content = 'locked B' WHERE id = 2;

7. Выполняем запрос на изменение в третьей сессии
BEGIN;
UPDATE test_table SET content = 'locked C' WHERE id = 3;

8. Выполняем запрос на изменения в первой сессии
UPDATE test_table SET content = 'wait B' WHERE id = 2;

9. Выполняем запрос на изменение во второй сессии
UPDATE test_table SET content = 'wait C' WHERE id = 3;

10. Выполняем запрос на изменение в третьей сессии
UPDATE test_table SET content = 'wait A' WHERE id = 1;

11. PostgreSQL увидил взаимоблокировку и завершил одну из транзакций с ошибкой:
ERROR:  deadlock detected
DETAIL:  Process 105 waits for ShareLock on transaction 169698; blocked by process 58.
Process 58 waits for ShareLock on transaction 169699; blocked by process 69.
Process 69 waits for ShareLock on transaction 169700; blocked by process 105.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,1) in relation "test_table"